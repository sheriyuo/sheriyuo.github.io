---
layout: post
title:  2023 年中国人民大学程序设计校内赛 比赛记录
date:   2023-04-1 01:34:00
---

个人赛 rk2，果然是不会做题。但是拿了 ￥2000 还是挺香。

题目顺序按照 Div. 1（团队赛）排序。	

### B - Tick

**题意**

将 $\{a_i\}$ 划分为任意多个子序列，$a_l,\cdots,a_r$ 的权值为 $\lvert \sum_{l\leq i\leq r} a_i -m\rvert$，求所有划分方案中权值和最小值。

对于所有数据，$n\leq 5\times 10^6$，$1\leq a_i,m\leq 10^9$。

**题解**

显而易见的 dp

$$
f_i = \min_{j<i} \{f_j+|s_i-s_j-m|\}
$$

贡献其实就是一个凸壳的切点，或者说 $i$ 的转移点 $p_i$ 满足决策单调，反正就是很裸的四边形不等式。

对于 $i$ 二分栈求一下 $p_i$ 即可，时间复杂度 $O(n\log n)$。

直接按照 $s_i-s_j$ 和 $m$ 比较求分割点也是可以的，可以 $O(n)$。

感觉不如我出的 [[MtOI2019]不可视境界线](https://www.luogu.com.cn/problem/P5617)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define in inline
#define ll long long
#define db double
in int read() {int x;scanf("%d",&x);return x;}
const int N=5e6+6;
int n,m,a[N];ll f[N],g[N],s[N];
struct stk{int i,l;}q[N];
int main()
{
	n=read(),m=read();for(int i=1;i<=n;i++) a[i]=read(),s[i]=s[i-1]+a[i];
	memset(f,127,sizeof(f));
	f[0]=0;int k=1;q[1]={0,0};
	for(int i=1,j=1;i<=n;i++)
	{
		while(j<k&&q[j+1].l<=i) j++;
		f[i]=f[q[j].i]+abs(s[i]-s[q[j].i]-m);
		int l=i,r=n,mid,ans=-1;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(f[i]+abs(s[mid]-s[i]-m)<f[q[k].i]+abs(s[mid]-s[q[k].i]-m)) ans=mid,r=mid-1;
			else l=mid+1;
		}
		if(ans>0) q[++k]={i,ans};
	}
	cout<<f[n]<<endl;
}
```

###D - 元旦旅游

「复旦栋梁」之二

**题意**

给定一个 $n$ 个点的完全图，$i,j$ 之前的距离为 $d_{i,j}$，第 $i$ 个点的权值为 $w_i$。

$q$ 组询问，每次询问 $s,t$ 的最短路径，且中转点权值需要不大于参数 $w$。

对于所有数据，$n\leq 300$，$q\leq 10^5$，$w_i\leq 10^5$。

**题解**

离线下来对询问的 $w$ 排序，从小到大 Floyd 更新中转点即可。时间复杂度 $O(q\log q+n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define in inline
#define ll long long
#define db double
in int read() {int x;scanf("%d",&x);return x;}
const int N=3e2+5,M=1e7+5;
int n,m,d[N][N],ans[M];
struct qry{
	int u,v,w,i;
	in bool operator<(qry x)const{return w<x.w;}
}q[M];
struct poi{
	int i,w;
	in bool operator<(poi x)const{return w<x.w;}
}a[N];
in void upd(int i)
{
	int k=a[i].i;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(d[i][j]>d[i][k]+d[k][j])
	d[i][j]=d[i][k]+d[k][j];
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]={i,read()};
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) d[i][j]=read();
	for(int i=1;i<=m;i++) q[i]={read(),read(),read(),i};
	sort(a+1,a+n+1);sort(q+1,q+m+1);
	for(int i=1,j=0;i<=m;i++)
	{
		int u=q[i].u,v=q[i].v,w=q[i].w;
		while(j<n&&a[j+1].w<=w) upd(++j);
		ans[q[i].i]=d[u][v];
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
}
```

### H - 交易配对

**题意**

「模板」最近点对

**题解**

可以 $O(n\log n)$ 分治或者 multiset。

也可以期望 $O(n)$，记前 $i$ 个点的最近点对距离为 $s$，将平面以 $s$ 为边长划分为若干个网格，用 Hash 表存下每个网格内的点， 然后检查第 $i$ 个点所在网格的周围九个网格中的所有点，并更新答案。如果答案被更新，将网格图重构，检查的点数和重构的期望代价是 $O(1)$ 的。

虽然我写的更暴力的 $O(n\sqrt n)$。